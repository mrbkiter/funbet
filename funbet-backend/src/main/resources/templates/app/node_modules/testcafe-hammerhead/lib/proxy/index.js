'use strict';

exports.__esModule = true;

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _router = require('./router');

var _router2 = _interopRequireDefault(_router);

var _http = require('http');

var _http2 = _interopRequireDefault(_http);

var _url = require('../utils/url');

var urlUtils = _interopRequireWildcard(_url);

var _readFileRelative = require('read-file-relative');

var _http3 = require('../utils/http');

var _upload = require('../upload');

var _requestPipeline = require('../request-pipeline');

var _createShadowStylesheet = require('../shadow-ui/create-shadow-stylesheet');

var _createShadowStylesheet2 = _interopRequireDefault(_createShadowStylesheet);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Const
var CLIENT_SCRIPT = (0, _readFileRelative.readSync)('../client/hammerhead.js');

// Static
function parseServiceMsg(body) {
    body = body.toString();

    try {
        return JSON.parse(body);
    } catch (err) {
        return null;
    }
}

function createServerInfo(hostname, port, crossDomainPort) {
    return {
        hostname: hostname,
        port: port,
        crossDomainPort: crossDomainPort,
        domain: 'http://' + hostname + ':' + port
    };
}

// Proxy

var Proxy = function (_Router) {
    (0, _inherits3.default)(Proxy, _Router);

    function Proxy(hostname, port1, port2) {
        (0, _classCallCheck3.default)(this, Proxy);

        var _this = (0, _possibleConstructorReturn3.default)(this, _Router.call(this));

        _this.openSessions = {};

        _this.server1Info = createServerInfo(hostname, port1, port2);
        _this.server2Info = createServerInfo(hostname, port2, port1);
        _this.server1 = _http2.default.createServer(function (req, res) {
            return _this._onRequest(req, res, _this.server1Info);
        });
        _this.server2 = _http2.default.createServer(function (req, res) {
            return _this._onRequest(req, res, _this.server2Info);
        });

        _this.server1.listen(port1);
        _this.server2.listen(port2);

        _this.sockets = [];

        // BUG: GH-89
        _this._startSocketsCollecting();
        _this._registerServiceRoutes();
        return _this;
    }

    Proxy.prototype._closeSockets = function _closeSockets() {
        this.sockets.forEach(function (socket) {
            return socket.destroy();
        });
    };

    Proxy.prototype._startSocketsCollecting = function _startSocketsCollecting() {
        var _this2 = this;

        var handler = function handler(socket) {
            _this2.sockets.push(socket);
            socket.on('close', function () {
                return _this2.sockets.splice(_this2.sockets.indexOf(socket), 1);
            });
        };

        this.server1.on('connection', handler);
        this.server2.on('connection', handler);
    };

    Proxy.prototype._registerServiceRoutes = function _registerServiceRoutes() {
        var _this3 = this;

        this.GET('/hammerhead.js', {
            contentType: 'application/x-javascript',
            content: CLIENT_SCRIPT
        });

        this.POST('/ie9-file-reader-shim', _upload.ie9FileReaderShim);
        this.POST('/messaging', function (req, res, serverInfo) {
            return _this3._onServiceMessage(req, res, serverInfo);
        });
        this.GET('/task.js', function (req, res, serverInfo) {
            return _this3._onTaskScriptRequest(req, res, serverInfo, false);
        });
        this.GET('/iframe-task.js', function (req, res, serverInfo) {
            return _this3._onTaskScriptRequest(req, res, serverInfo, true);
        });
    };

    Proxy.prototype._onServiceMessage = function () {
        var _ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee(req, res, serverInfo) {
            var body, msg, session, result;
            return _regenerator2.default.wrap(function _callee$(_context) {
                while (1) {
                    switch (_context.prev = _context.next) {
                        case 0:
                            _context.next = 2;
                            return (0, _http3.fetchBody)(req);

                        case 2:
                            body = _context.sent;
                            msg = parseServiceMsg(body);
                            session = msg && this.openSessions[msg.sessionId];

                            if (!session) {
                                _context.next = 18;
                                break;
                            }

                            _context.prev = 6;
                            _context.next = 9;
                            return session.handleServiceMessage(msg, serverInfo);

                        case 9:
                            result = _context.sent;


                            (0, _http3.respondWithJSON)(res, result || '');
                            _context.next = 16;
                            break;

                        case 13:
                            _context.prev = 13;
                            _context.t0 = _context['catch'](6);

                            (0, _http3.respond500)(res, _context.t0.toString());

                        case 16:
                            _context.next = 19;
                            break;

                        case 18:
                            (0, _http3.respond500)(res, 'Session is not opened in proxy');

                        case 19:
                        case 'end':
                            return _context.stop();
                    }
                }
            }, _callee, this, [[6, 13]]);
        }));

        function _onServiceMessage(_x, _x2, _x3) {
            return _ref.apply(this, arguments);
        }

        return _onServiceMessage;
    }();

    Proxy.prototype._onTaskScriptRequest = function _onTaskScriptRequest(req, res, serverInfo, isIframe) {
        var referer = req.headers['referer'];
        var refererDest = referer && urlUtils.parseProxyUrl(referer);
        var session = refererDest && this.openSessions[refererDest.sessionId];

        if (session) {
            res.setHeader('content-type', 'application/x-javascript');
            (0, _http3.preventCaching)(res);
            res.end(session.getTaskScript(referer, refererDest.destUrl, serverInfo, isIframe, true));
        } else (0, _http3.respond500)(res);
    };

    Proxy.prototype._onRequest = function _onRequest(req, res, serverInfo) {
        // NOTE: Not a service request, execute the proxy pipeline.
        if (!this._route(req, res, serverInfo)) (0, _requestPipeline.run)(req, res, serverInfo, this.openSessions);
    };

    Proxy.prototype._processStaticContent = function _processStaticContent(handler) {
        if (handler.isShadowUIStylesheet) handler.content = (0, _createShadowStylesheet2.default)(handler.content);
    };

    // API


    Proxy.prototype.close = function close() {
        this.server1.close();
        this.server2.close();
        this._closeSockets();
    };

    Proxy.prototype.openSession = function openSession(url, session) {
        session.proxy = this;
        this.openSessions[session.id] = session;

        return urlUtils.getProxyUrl(url, {
            proxyHostname: this.server1Info.hostname,
            proxyPort: this.server1Info.port,
            sessionId: session.id
        });
    };

    Proxy.prototype.closeSession = function closeSession(session) {
        session.proxy = null;
        delete this.openSessions[session.id];
    };

    return Proxy;
}(_router2.default);

exports.default = Proxy;
module.exports = exports['default'];