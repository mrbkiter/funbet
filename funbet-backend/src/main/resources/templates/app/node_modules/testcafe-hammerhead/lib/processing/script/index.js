'use strict';

exports.__esModule = true;
exports.isScriptProcessed = isScriptProcessed;
exports.processScript = processScript;

var _transform = require('./transform');

var _transform2 = _interopRequireDefault(_transform);

var _instruction = require('./instruction');

var _instruction2 = _interopRequireDefault(_instruction);

var _header = require('./header');

var _acorn = require('./tools/acorn');

var _esotope = require('./tools/esotope');

var _regexpEscape = require('../../utils/regexp-escape');

var _regexpEscape2 = _interopRequireDefault(_regexpEscape);

var _getBom = require('../../utils/get-bom');

var _getBom2 = _interopRequireDefault(_getBom);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Const
var HTML_COMMENT_RE = /(^|\n)\s*<!--[^\n]*(\n|$)/g; // -------------------------------------------------------------
// WARNING: this file is used by both the client and the server.
// Do not use any browser or node-specific API!
// -------------------------------------------------------------

var OBJECT_RE = /^\s*\{.*\}\s*$/;
var TRAILING_SEMICOLON_RE = /;\s*$/;
var OBJECT_WRAPPER_RE = /^\s*\((.*)\);\s*$/;

var PROCESSED_SCRIPT_RE = new RegExp([(0, _regexpEscape2.default)(_instruction2.default.getLocation), (0, _regexpEscape2.default)(_instruction2.default.setLocation), (0, _regexpEscape2.default)(_instruction2.default.getProperty), (0, _regexpEscape2.default)(_instruction2.default.setProperty), (0, _regexpEscape2.default)(_instruction2.default.callMethod), (0, _regexpEscape2.default)(_instruction2.default.processScript), (0, _regexpEscape2.default)(_instruction2.default.getStorage), (0, _regexpEscape2.default)(_instruction2.default.getPostMessage)].join('|'));

// Code pre/post-processing
function removeHtmlComments(code) {
    // NOTE: The JS parser removes the line that follows'<!--'. (T226589)
    do {
        code = code.replace(HTML_COMMENT_RE, '\n');
    } while (HTML_COMMENT_RE.test(code));

    return code;
}

function preprocess(code) {
    var bom = (0, _getBom2.default)(code);
    var preprocessed = bom ? code.substring(bom.length) : code;

    preprocessed = (0, _header.remove)(preprocessed);

    return { bom: bom, preprocessed: preprocessed };
}

function postprocess(processed, withHeader, bom, strictMode) {
    // NOTE: If the 'use strict' directive is not in the beginning of the file, it is ignored.
    // As we insert our header in the beginning of the script, we must put a new 'use strict'
    // before the header, otherwise it will be ignored.
    if (withHeader) processed = (0, _header.add)(processed, strictMode);

    return bom ? bom + processed : processed;
}

// Parse/generate code
function removeTrailingSemicolonIfNecessary(processed, src) {
    return TRAILING_SEMICOLON_RE.test(src) ? processed : processed.replace(TRAILING_SEMICOLON_RE, '');
}

function getAst(src, isObject) {
    // NOTE: In case of objects (e.g.eval('{ 1: 2}')) without wrapping
    // object will be parsed as label. To avoid this we parenthesize src
    src = isObject ? '(' + src + ')' : src;

    try {
        return (0, _acorn.parse)(src, { allowReturnOutsideFunction: true });
    } catch (err) {
        return null;
    }
}

function getCode(ast, src) {
    var code = (0, _esotope.generate)(ast, {
        format: {
            quotes: 'double',
            escapeless: true,
            compact: true
        }
    });

    return src ? removeTrailingSemicolonIfNecessary(code, src) : code;
}

// Analyze code
function analyze(code) {
    var isObject = OBJECT_RE.test(code);
    var ast = getAst(code, isObject);

    // NOTE: `{ var a = 'foo'; }` edge case
    if (!ast && isObject) {
        ast = getAst(code, false);
        isObject = false;
    }

    return { ast: ast, isObject: isObject };
}

function isArrayDataScript(ast) {
    return ast.body.length === 1 && ast.body[0].type === _esotope.Syntax.ExpressionStatement && ast.body[0].expression.type === _esotope.Syntax.ArrayExpression;
}

function isStrictMode(ast) {
    if (ast.body.length) {
        var firstChild = ast.body[0];

        if (firstChild.type === _esotope.Syntax.ExpressionStatement && firstChild.expression.type === _esotope.Syntax.Literal) return firstChild.expression.value === 'use strict';
    }

    return false;
}

function applyChanges(script, changes, isObject) {
    var indexOffset = isObject ? -1 : 0;
    var chunks = [];
    var index = 0;

    if (!changes.length) return script;

    changes.sort(function (a, b) {
        return a.start - b.start;
    });

    for (var i = 0; i < changes.length; i++) {
        var change = changes[i];
        var changeStart = change.start + indexOffset;
        var changeEnd = change.end + indexOffset;
        var replacement = change.parent[change.key];

        replacement = change.index !== -1 ? replacement[change.index] : replacement;
        chunks.push(script.substring(index, changeStart));
        chunks.push(' ');
        chunks.push(getCode(replacement, script.substring(changeStart, changeEnd)));
        index += changeEnd - index;
    }

    chunks.push(script.substring(index));

    return chunks.join('');
}

function isScriptProcessed(code) {
    return PROCESSED_SCRIPT_RE.test(code);
}

function processScript(src, withHeader) {
    var _preprocess = preprocess(src);

    var bom = _preprocess.bom;
    var preprocessed = _preprocess.preprocessed;

    var withoutHtmlComments = removeHtmlComments(preprocessed);

    var _analyze = analyze(withoutHtmlComments);

    var ast = _analyze.ast;
    var isObject = _analyze.isObject;


    if (!ast) return src;

    withHeader = withHeader && !isObject && !isArrayDataScript(ast);

    var changes = (0, _transform2.default)(ast);
    var processed = changes.length ? applyChanges(withoutHtmlComments, changes, isObject) : preprocessed;

    processed = postprocess(processed, withHeader, bom, isStrictMode(ast));

    if (isObject) processed = processed.replace(OBJECT_WRAPPER_RE, '$1');

    return processed;
}