'use strict';

exports.__esModule = true;
exports.SPECIAL_PAGES = exports.REQUEST_DESCRIPTOR_VALUES_SEPARATOR = exports.HASH_RE = exports.SUPPORTED_PROTOCOL_RE = undefined;
exports.parseResourceType = parseResourceType;
exports.getResourceTypeString = getResourceTypeString;
exports.isSubDomain = isSubDomain;
exports.sameOriginCheck = sameOriginCheck;
exports.getProxyUrl = getProxyUrl;
exports.getDomain = getDomain;
exports.parseProxyUrl = parseProxyUrl;
exports.getPathname = getPathname;
exports.parseUrl = parseUrl;
exports.isSupportedProtocol = isSupportedProtocol;
exports.resolveUrlAsDest = resolveUrlAsDest;
exports.formatUrl = formatUrl;
exports.prepareUrl = prepareUrl;
exports.ensureTrailingSlash = ensureTrailingSlash;
exports.isSpecialPage = isSpecialPage;
exports.isRelativeUrl = isRelativeUrl;
exports.isValidUrl = isValidUrl;

var _stringTrim = require('./string-trim');

var _stringTrim2 = _interopRequireDefault(_stringTrim);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//Const
var PROTOCOL_RE = /(^([\w-]+?\:))/; // -------------------------------------------------------------
// WARNING: this file is used by both the client and the server.
// Do not use any browser or node-specific API!
// -------------------------------------------------------------

var LEADING_SLASHES_RE = /^(\/\/)/;
var HOST_RE = /^(.*?)(\/|%|\?|;|#|$)/;
var PORT_RE = /:([0-9]*)$/;
var QUERY_AND_HASH_RE = /(\?.+|#[^#]*)$/;
var PATH_AFTER_HOST_RE = /^\/([^\/]+?)\/([\S\s]+)$/;

var SUPPORTED_PROTOCOL_RE = exports.SUPPORTED_PROTOCOL_RE = /^https?:/i;
var HASH_RE = exports.HASH_RE = /^#/;
var REQUEST_DESCRIPTOR_VALUES_SEPARATOR = exports.REQUEST_DESCRIPTOR_VALUES_SEPARATOR = '!';
var SPECIAL_PAGES = exports.SPECIAL_PAGES = ['about:blank', 'about:error'];

function parseResourceType(resourceType) {
    if (!resourceType) {
        return {
            isIframe: false,
            isForm: false,
            isScript: false
        };
    }

    return {
        isIframe: /i/.test(resourceType),
        isForm: /f/.test(resourceType),
        isScript: /s/.test(resourceType)
    };
}

function getResourceTypeString(resourceType) {
    resourceType = resourceType || {};

    if (!resourceType.isIframe && !resourceType.isForm && !resourceType.isScript) return null;

    return [resourceType.isIframe ? 'i' : '', resourceType.isForm ? 'f' : '', resourceType.isScript ? 's' : ''].join('');
}

function isSubDomain(domain, subDomain) {
    domain = domain.replace(/^www./i, '');
    subDomain = subDomain.replace(/^www./i, '');

    if (domain === subDomain) return true;

    var index = subDomain.lastIndexOf(domain);

    return subDomain[index - 1] === '.' && subDomain.length === index + domain.length;
}

function sameOriginCheck(location, checkedUrl, rejectForSubdomains) {
    if (!checkedUrl) return true;

    var parsedLocation = parseUrl(location);
    var parsedCheckedUrl = parseUrl(checkedUrl);
    var parsedProxyLocation = parseProxyUrl(location);
    var parsedDestUrl = parsedProxyLocation ? parsedProxyLocation.destResourceInfo : parsedLocation;
    var isRelative = !parsedCheckedUrl.host;

    if (isRelative || parsedCheckedUrl.host === parsedLocation.host && parsedCheckedUrl.protocol === parsedLocation.protocol) return true;

    if (parsedDestUrl) {
        var portsEq = !parsedDestUrl.port && !parsedCheckedUrl.port || parsedDestUrl.port && parsedDestUrl.port.toString() === parsedCheckedUrl.port;

        if (parsedDestUrl.protocol === parsedCheckedUrl.protocol && portsEq) {
            if (parsedDestUrl.hostname === parsedCheckedUrl.hostname) return true;

            var isSubDomainHostname = isSubDomain(parsedDestUrl.hostname, parsedCheckedUrl.hostname) || isSubDomain(parsedCheckedUrl.hostname, parsedDestUrl.hostname);

            return !rejectForSubdomains && isSubDomainHostname;
        }
    }

    return false;
}

// NOTE: Convert the destination protocol and hostname to the lower case. (GH-1)
function convertHostToLowerCase(url) {
    var parsedUrl = parseUrl(url);
    var protocolHostSeparator = parsedUrl.protocol === 'about:' ? '' : '//';

    return (parsedUrl.protocol + protocolHostSeparator + parsedUrl.host).toLowerCase() + parsedUrl.partAfterHost;
}

function getProxyUrl(url, opts) {
    var params = [opts.sessionId];

    if (opts.resourceType) params.push(opts.resourceType);

    if (opts.charset) params.push(opts.charset.toLowerCase());

    params = params.join(REQUEST_DESCRIPTOR_VALUES_SEPARATOR);

    return 'http://' + opts.proxyHostname + ':' + opts.proxyPort + '/' + params + '/' + convertHostToLowerCase(url);
}

function getDomain(parsed) {
    return formatUrl({
        protocol: parsed.protocol,
        host: parsed.host,
        hostname: parsed.hostname,
        port: parsed.port
    });
}

function parseProxyUrl(proxyUrl) {
    // TODO: Remove it.
    var parsedUrl = parseUrl(proxyUrl);

    if (!parsedUrl.partAfterHost) return null;

    var match = parsedUrl.partAfterHost.match(PATH_AFTER_HOST_RE);

    if (!match) return null;

    var params = match[1].split(REQUEST_DESCRIPTOR_VALUES_SEPARATOR);

    // NOTE: We should have, at least, the job uid and the owner token.
    if (!params.length) return null;

    var destUrl = match[2];

    if (!isSpecialPage(destUrl) && !SUPPORTED_PROTOCOL_RE.test(destUrl)) return null;

    var destResourceInfo = !isSpecialPage(destUrl) ? parseUrl(match[2]) : {
        protocol: 'about:',
        host: '',
        hostname: '',
        port: '',
        partAfterHost: ''
    };

    return {
        destUrl: destUrl,
        destResourceInfo: destResourceInfo,
        partAfterHost: parsedUrl.partAfterHost,

        proxy: {
            hostname: parsedUrl.hostname,
            port: parsedUrl.port
        },

        sessionId: params[0],
        resourceType: params[1] || null,
        charset: params[2] || null
    };
}

function getPathname(path) {
    return path.replace(QUERY_AND_HASH_RE, '');
}

function parseUrl(url) {
    var parsed = {};

    url = prepareUrl(url);

    if (!url) return parsed;

    url = (0, _stringTrim2.default)(url);

    // Protocol
    var hasImplicitProtocol = false;
    var remainder = url.replace(PROTOCOL_RE, function (str, protocol) {
        parsed.protocol = protocol;
        return '';
    }).replace(LEADING_SLASHES_RE, function () {
        hasImplicitProtocol = true;
        return '';
    });

    // NOTE: the URL is relative.
    if (!parsed.protocol && !hasImplicitProtocol) {
        parsed.partAfterHost = url;
        return parsed;
    }

    // Host
    parsed.partAfterHost = remainder.replace(HOST_RE, function (str, host, restPartSeparator) {
        parsed.host = host;
        return restPartSeparator;
    });

    if (parsed.host) {
        parsed.hostname = parsed.host.replace(PORT_RE, function (str, port) {
            parsed.port = port;
            return '';
        });
    }

    return parsed;
}

function isSupportedProtocol(url) {
    url = (0, _stringTrim2.default)(url || '');

    var isHash = HASH_RE.test(url);

    if (isHash) return false;

    var protocol = url.match(PROTOCOL_RE);

    if (!protocol) return true;

    return SUPPORTED_PROTOCOL_RE.test(protocol[0]);
}

function resolveUrlAsDest(url, getProxyUrlMeth) {
    getProxyUrlMeth = getProxyUrlMeth || getProxyUrl;

    if (isSupportedProtocol(url)) {
        var proxyUrl = getProxyUrlMeth(url);
        var parsedProxyUrl = parseProxyUrl(proxyUrl);

        return formatUrl(parsedProxyUrl.destResourceInfo);
    }

    return url;
}

function formatUrl(parsedUrl) {
    // NOTE: the URL is relative.
    if (!parsedUrl.host && (!parsedUrl.hostname || !parsedUrl.port)) return parsedUrl.partAfterHost;

    var url = parsedUrl.protocol || '';

    url += '//';

    if (parsedUrl.username || parsedUrl.password) url += parsedUrl.username + ':' + parsedUrl.password + '@';

    if (parsedUrl.host) url += parsedUrl.host;else {
        url += parsedUrl.hostname;

        if (parsedUrl.port) url += ':' + parsedUrl.port;
    }

    if (parsedUrl.partAfterHost) url += parsedUrl.partAfterHost;

    return url;
}

function prepareUrl(url) {
    // TODO: fix it
    /* eslint-disable no-undef */
    if (url === null && /iPad|iPhone/i.test(window.navigator.userAgent)) return '';
    /* eslint-enable no-undef */

    url = String(url);
    url = url.replace(/\n|\t/g, '');

    // NOTE: Remove unnecessary slashes from the beginning of the url and after scheme.
    // For example:
    // "//////example.com" -> "//example.com".
    // "http:///example.com" -> "http://example.com"
    return url.replace(/^(https?:)?\/+(\/\/.*$)/i, '$1$2');
}

function ensureTrailingSlash(srcUrl, processedUrl) {
    var hasTrailingSlash = /\/$/.test(srcUrl);

    if (!hasTrailingSlash) processedUrl = processedUrl.replace(/\/$/, '');

    return processedUrl;
}

function isSpecialPage(url) {
    return SPECIAL_PAGES.indexOf(url) !== -1;
}

function isRelativeUrl(url) {
    var parsedUrl = parseUrl(url);

    return !parsedUrl.host;
}

function isValidPort(port) {
    var parsedPort = parseInt(port, 10);

    return parsedPort > 0 && parsedPort <= 65535;
}

function isValidUrl(url) {
    var parsedUrl = parseUrl(url);

    if (!parsedUrl.hostname || parsedUrl.port && !isValidPort(parsedUrl.port)) return false;

    return true;
}