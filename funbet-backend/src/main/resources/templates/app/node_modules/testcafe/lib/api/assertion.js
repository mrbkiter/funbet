'use strict';

exports.__esModule = true;

var _typeof2 = require('babel-runtime/helpers/typeof');

var _typeof3 = _interopRequireDefault(_typeof2);

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _chai = require('chai');

var _lodash = require('lodash');

var _delay = require('../utils/delay');

var _delay2 = _interopRequireDefault(_delay);

var _testRun = require('../errors/test-run');

var _typeAssertions = require('../errors/runtime/type-assertions');

var _resultPromise = require('../client-functions/result-promise');

var _resultPromise2 = _interopRequireDefault(_resultPromise);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ASSERTION_DELAY = 200;

var Assertion = function () {
    function Assertion(actual, testContoller) {
        (0, _classCallCheck3.default)(this, Assertion);

        this.actual = actual;
        this.testController = testContoller;
        this.message = void 0;
        this.opts = {};
    }

    Assertion.prototype._wrapSelectorResultAssertionExecutor = function _wrapSelectorResultAssertionExecutor(executor) {
        var _this = this;

        return (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee() {
            var startTime, resultPromise, passed, timeout;
            return _regenerator2.default.wrap(function _callee$(_context) {
                while (1) {
                    switch (_context.prev = _context.next) {
                        case 0:
                            startTime = new Date();
                            resultPromise = _this.actual;
                            passed = false;
                            timeout = _this.opts.timeout === void 0 ? _this.testController.testRun.opts.assertionTimeout : _this.opts.timeout;

                        case 4:
                            if (passed) {
                                _context.next = 21;
                                break;
                            }

                            _context.next = 7;
                            return resultPromise._reExecute();

                        case 7:
                            _this.actual = _context.sent;
                            _context.prev = 8;

                            executor();
                            passed = true;
                            _context.next = 19;
                            break;

                        case 13:
                            _context.prev = 13;
                            _context.t0 = _context['catch'](8);

                            if (!(new Date() - startTime >= timeout)) {
                                _context.next = 17;
                                break;
                            }

                            throw _context.t0;

                        case 17:
                            _context.next = 19;
                            return (0, _delay2.default)(ASSERTION_DELAY);

                        case 19:
                            _context.next = 4;
                            break;

                        case 21:
                        case 'end':
                            return _context.stop();
                    }
                }
            }, _callee, _this, [[8, 13]]);
        }));
    };

    Assertion.prototype._wrapExecutor = function _wrapExecutor(callsite, executor) {
        var _this2 = this;

        if (this.actual instanceof _resultPromise2.default) executor = this._wrapSelectorResultAssertionExecutor(executor);

        return (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee2() {
            return _regenerator2.default.wrap(function _callee2$(_context2) {
                while (1) {
                    switch (_context2.prev = _context2.next) {
                        case 0:
                            _context2.prev = 0;
                            _context2.next = 3;
                            return executor();

                        case 3:
                            _context2.next = 11;
                            break;

                        case 5:
                            _context2.prev = 5;
                            _context2.t0 = _context2['catch'](0);

                            if (!(_context2.t0.name === 'AssertionError' || _context2.t0.constructor.name === 'AssertionError')) {
                                _context2.next = 9;
                                break;
                            }

                            throw new _testRun.ExternalAssertionLibraryError(_context2.t0, callsite);

                        case 9:

                            if (_context2.t0.isTestCafeError) _context2.t0.callsite = callsite;

                            throw _context2.t0;

                        case 11:
                        case 'end':
                            return _context2.stop();
                    }
                }
            }, _callee2, _this2, [[0, 5]]);
        }));
    };

    Assertion.prototype._enqueueAssertion = function _enqueueAssertion(apiMethodName, message, opts, executor) {
        var _this3 = this;

        if ((typeof message === 'undefined' ? 'undefined' : (0, _typeof3.default)(message)) === 'object') opts = message;else this.message = message;

        this.opts = (0, _lodash.assign)(this.opts, opts);

        if (this.opts.timeout !== void 0) (0, _typeAssertions.assertNonNegativeNumber)(apiMethodName, '"timeout" option', this.opts.timeout);

        return this.testController._enqueueTask(apiMethodName, function (callsite) {
            return _this3._wrapExecutor(callsite, executor);
        });
    };

    Assertion.prototype.eql = function eql(expected, message, opts) {
        var _this4 = this;

        return this._enqueueAssertion('eql', message, opts, function () {
            return _chai.assert.deepEqual(_this4.actual, expected, _this4.message);
        });
    };

    Assertion.prototype.notEql = function notEql(unexpected, message, opts) {
        var _this5 = this;

        return this._enqueueAssertion('notEql', message, opts, function () {
            return _chai.assert.notDeepEqual(_this5.actual, unexpected, _this5.message);
        });
    };

    Assertion.prototype.ok = function ok(message, opts) {
        var _this6 = this;

        return this._enqueueAssertion('ok', message, opts, function () {
            return _chai.assert.isOk(_this6.actual, _this6.message);
        });
    };

    Assertion.prototype.notOk = function notOk(message, opts) {
        var _this7 = this;

        return this._enqueueAssertion('notOk', message, opts, function () {
            return _chai.assert.isNotOk(_this7.actual, _this7.message);
        });
    };

    Assertion.prototype.contains = function contains(what, message, opts) {
        var _this8 = this;

        return this._enqueueAssertion('contains', message, opts, function () {
            return _chai.assert.include(_this8.actual, what, _this8.message);
        });
    };

    Assertion.prototype.notContains = function notContains(what, message, opts) {
        var _this9 = this;

        return this._enqueueAssertion('notContains', message, opts, function () {
            return _chai.assert.notInclude(_this9.actual, what, _this9.message);
        });
    };

    Assertion.prototype.typeOf = function typeOf(type, message, opts) {
        var _this10 = this;

        return this._enqueueAssertion('typeOf', message, opts, function () {
            return _chai.assert.typeOf(_this10.actual, type, _this10.message);
        });
    };

    Assertion.prototype.notTypeOf = function notTypeOf(type, message, opts) {
        var _this11 = this;

        return this._enqueueAssertion('notTypeOf', message, opts, function () {
            return _chai.assert.notTypeOf(_this11.actual, type, _this11.message);
        });
    };

    Assertion.prototype.gt = function gt(expected, message, opts) {
        var _this12 = this;

        return this._enqueueAssertion('gt', message, opts, function () {
            return _chai.assert.isAbove(_this12.actual, expected, _this12.message);
        });
    };

    Assertion.prototype.gte = function gte(expected, message, opts) {
        var _this13 = this;

        return this._enqueueAssertion('gte', message, opts, function () {
            return _chai.assert.isAtLeast(_this13.actual, expected, _this13.message);
        });
    };

    Assertion.prototype.lt = function lt(expected, message, opts) {
        var _this14 = this;

        return this._enqueueAssertion('lt', message, opts, function () {
            return _chai.assert.isBelow(_this14.actual, expected, _this14.message);
        });
    };

    Assertion.prototype.lte = function lte(expected, message, opts) {
        var _this15 = this;

        return this._enqueueAssertion('lte', message, opts, function () {
            return _chai.assert.isAtMost(_this15.actual, expected, _this15.message);
        });
    };

    Assertion.prototype.within = function within(lo, hi, message, opts) {
        var _this16 = this;

        // NOTE: `within` is not available in Chai `assert` interface.
        return this._enqueueAssertion('within', message, opts, function () {
            return (0, _chai.expect)(_this16.actual).to.be.within(lo, hi, _this16.message);
        });
    };

    Assertion.prototype.notWithin = function notWithin(lo, hi, message, opts) {
        var _this17 = this;

        return this._enqueueAssertion('notWithin', message, opts, function () {
            return (0, _chai.expect)(_this17.actual).not.to.be.within(lo, hi, _this17.message);
        });
    };

    Assertion.prototype.match = function match(re, message, opts) {
        var _this18 = this;

        return this._enqueueAssertion('match', message, opts, function () {
            return _chai.assert.match(_this18.actual, re, _this18.message);
        });
    };

    Assertion.prototype.notMatch = function notMatch(re, message, opts) {
        var _this19 = this;

        return this._enqueueAssertion('notMatch', message, opts, function () {
            return _chai.assert.notMatch(_this19.actual, re, _this19.message);
        });
    };

    return Assertion;
}();

exports.default = Assertion;
module.exports = exports['default'];