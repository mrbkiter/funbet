'use strict';

exports.__esModule = true;

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _pinkie = require('pinkie');

var _pinkie2 = _interopRequireDefault(_pinkie);

var _lodash = require('lodash');

var _testRun = require('../errors/test-run');

var _getCallsite = require('../errors/get-callsite');

var _getCallsite2 = _interopRequireDefault(_getCallsite);

var _deprecate = require('../warnings/deprecate');

var _deprecate2 = _interopRequireDefault(_deprecate);

var _clientFunctionBuilder = require('../client-functions/client-function-builder');

var _clientFunctionBuilder2 = _interopRequireDefault(_clientFunctionBuilder);

var _selectorBuilder = require('../client-functions/selector-builder');

var _selectorBuilder2 = _interopRequireDefault(_selectorBuilder);

var _assertion = require('./assertion');

var _assertion2 = _interopRequireDefault(_assertion);

var _delegatedApi = require('../utils/delegated-api');

var _actions = require('../test-run/commands/actions');

var _browserManipulation = require('../test-run/commands/browser-manipulation');

var _observation = require('../test-run/commands/observation');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var TestController = function () {
    function TestController(testRun) {
        (0, _classCallCheck3.default)(this, TestController);

        this.testRun = testRun;
        this.executionChain = _pinkie2.default.resolve();
        this.callsiteWithoutAwait = null;
    }

    // NOTE: we track missing `awaits` by exposing a special custom Promise to user code.
    // Action or assertion is awaited if:
    // a)someone used `await` so Promise's `then` function executed
    // b)Promise chained by using one of the mixed-in controller methods
    //
    // In both scenarios, we check that callsite that produced Promise is equal to the one
    // that is currently missing await. This is required to workaround scenarios like this:
    //
    // var t2 = t.click('#btn1'); // <-- stores new callsiteWithoutAwait
    // await t2;                  // <-- callsiteWithoutAwait = null
    // t.click('#btn2');          // <-- stores new callsiteWithoutAwait
    // await t2.click('#btn3');   // <-- without check it will set callsiteWithoutAwait = null, so we will lost tracking


    TestController.prototype._createExtendedPromise = function _createExtendedPromise(promise, callsite) {
        var _this = this;

        var extendedPromise = promise.then(_lodash.identity);
        var originalThen = extendedPromise.then;

        var ensureAwait = function ensureAwait() {
            if (_this.callsiteWithoutAwait === callsite) _this.callsiteWithoutAwait = null;
        };

        extendedPromise.then = function () {
            ensureAwait();
            return originalThen.apply(this, arguments);
        };

        (0, _delegatedApi.delegateAPI)(this, extendedPromise, TestController.API_LIST, ensureAwait, false);

        return extendedPromise;
    };

    TestController.prototype._enqueueTask = function _enqueueTask(apiMethodName, createTaskExecutor) {
        this._checkForMissingAwait();

        var callsite = (0, _getCallsite2.default)(apiMethodName);
        var executor = createTaskExecutor(callsite);

        this.executionChain = this.executionChain.then(executor);
        this.callsiteWithoutAwait = callsite;

        return this._createExtendedPromise(this.executionChain, callsite);
    };

    TestController.prototype._enqueueAction = function _enqueueAction(apiMethodName, CmdCtor, cmdArgs) {
        var _this2 = this;

        return this._enqueueTask(apiMethodName, function (callsite) {
            var command = null;

            try {
                command = new CmdCtor(cmdArgs);
            } catch (err) {
                err.callsite = callsite;
                throw err;
            }

            return function () {
                return _this2.testRun.executeCommand(command, callsite);
            };
        });
    };

    TestController.prototype._checkForMissingAwait = function _checkForMissingAwait() {
        if (this.callsiteWithoutAwait) throw new _testRun.MissingAwaitError(this.callsiteWithoutAwait);
    };

    // API implementation
    // We need implementation methods to obtain correct callsites. If we use plain API
    // methods in chained wrappers then we will have callsite for the wrapped method
    // in this file instead of chained method callsite in user code.


    TestController.prototype._ctx$getter = function _ctx$getter() {
        return this.testRun.ctx;
    };

    TestController.prototype._ctx$setter = function _ctx$setter(val) {
        this.testRun.ctx = val;

        return this.testRun.ctx;
    };

    TestController.prototype._click$ = function _click$(selector, options) {
        return this._enqueueAction('click', _actions.ClickCommand, { selector: selector, options: options });
    };

    TestController.prototype._rightClick$ = function _rightClick$(selector, options) {
        return this._enqueueAction('rightClick', _actions.RightClickCommand, { selector: selector, options: options });
    };

    TestController.prototype._doubleClick$ = function _doubleClick$(selector, options) {
        return this._enqueueAction('doubleClick', _actions.DoubleClickCommand, { selector: selector, options: options });
    };

    TestController.prototype._hover$ = function _hover$(selector, options) {
        return this._enqueueAction('hover', _actions.HoverCommand, { selector: selector, options: options });
    };

    TestController.prototype._drag$ = function _drag$(selector, dragOffsetX, dragOffsetY, options) {
        return this._enqueueAction('drag', _actions.DragCommand, { selector: selector, dragOffsetX: dragOffsetX, dragOffsetY: dragOffsetY, options: options });
    };

    TestController.prototype._dragToElement$ = function _dragToElement$(selector, destinationSelector, options) {
        return this._enqueueAction('dragToElement', _actions.DragToElementCommand, { selector: selector, destinationSelector: destinationSelector, options: options });
    };

    TestController.prototype._typeText$ = function _typeText$(selector, text, options) {
        return this._enqueueAction('typeText', _actions.TypeTextCommand, { selector: selector, text: text, options: options });
    };

    TestController.prototype._selectText$ = function _selectText$(selector, startPos, endPos) {
        return this._enqueueAction('selectText', _actions.SelectTextCommand, { selector: selector, startPos: startPos, endPos: endPos });
    };

    TestController.prototype._selectTextAreaContent$ = function _selectTextAreaContent$(selector, startLine, startPos, endLine, endPos) {
        return this._enqueueAction('selectTextAreaContent', _actions.SelectTextAreaContentCommand, {
            selector: selector,
            startLine: startLine,
            startPos: startPos,
            endLine: endLine,
            endPos: endPos
        });
    };

    TestController.prototype._selectEditableContent$ = function _selectEditableContent$(startSelector, endSelector) {
        return this._enqueueAction('selectEditableContent', _actions.SelectEditableContentCommand, {
            startSelector: startSelector,
            endSelector: endSelector
        });
    };

    TestController.prototype._pressKey$ = function _pressKey$(keys) {
        return this._enqueueAction('pressKey', _actions.PressKeyCommand, { keys: keys });
    };

    TestController.prototype._wait$ = function _wait$(timeout) {
        return this._enqueueAction('wait', _observation.WaitCommand, { timeout: timeout });
    };

    TestController.prototype._navigateTo$ = function _navigateTo$(url) {
        return this._enqueueAction('navigateTo', _actions.NavigateToCommand, { url: url });
    };

    TestController.prototype._setFilesToUpload$ = function _setFilesToUpload$(selector, filePath) {
        return this._enqueueAction('setFilesToUpload', _actions.SetFilesToUploadCommand, { selector: selector, filePath: filePath });
    };

    TestController.prototype._clearUpload$ = function _clearUpload$(selector) {
        return this._enqueueAction('clearUpload', _actions.ClearUploadCommand, { selector: selector });
    };

    TestController.prototype._takeScreenshot$ = function _takeScreenshot$(path) {
        return this._enqueueAction('takeScreenshot', _browserManipulation.TakeScreenshotCommand, { path: path });
    };

    TestController.prototype._resizeWindow$ = function _resizeWindow$(width, height) {
        return this._enqueueAction('resizeWindow', _browserManipulation.ResizeWindowCommand, { width: width, height: height });
    };

    TestController.prototype._resizeWindowToFitDevice$ = function _resizeWindowToFitDevice$(device, options) {
        return this._enqueueAction('resizeWindowToFitDevice', _browserManipulation.ResizeWindowToFitDeviceCommand, { device: device, options: options });
    };

    TestController.prototype._maximizeWindow$ = function _maximizeWindow$() {
        return this._enqueueAction('maximizeWindow', _browserManipulation.MaximizeWindowCommand);
    };

    TestController.prototype._switchToIframe$ = function _switchToIframe$(selector) {
        return this._enqueueAction('switchToIframe', _actions.SwitchToIframeCommand, { selector: selector });
    };

    TestController.prototype._switchToMainWindow$ = function _switchToMainWindow$() {
        return this._enqueueAction('switchToMainWindow', _actions.SwitchToMainWindowCommand);
    };

    TestController.prototype._eval$ = function _eval$(fn, options) {
        if (!(0, _lodash.isNil)(options)) options = (0, _lodash.assign)({}, options, { boundTestRun: this });

        var builder = new _clientFunctionBuilder2.default(fn, options, { instantiation: 'eval', execution: 'eval' });
        var clientFn = builder.getFunction();

        return clientFn();
    };

    TestController.prototype._select$ = function _select$(fn, options) {
        (0, _deprecate2.default)((0, _getCallsite2.default)('select'), {
            what: 't.select',
            useInstead: 'Selector'
        });

        if (!(0, _lodash.isNil)(options)) options = (0, _lodash.assign)({}, options, { boundTestRun: this });

        var builder = new _selectorBuilder2.default(fn, options, { instantiation: 'select', execution: 'select' });
        var selector = builder.getFunction();

        return selector();
    };

    TestController.prototype._setNativeDialogHandler$ = function _setNativeDialogHandler$(dialogHandler, options) {
        return this._enqueueAction('setNativeDialogHandler', _actions.SetNativeDialogHandlerCommand, {
            dialogHandler: {
                dialogHandler: dialogHandler,
                options: options
            }
        });
    };

    TestController.prototype._getNativeDialogHistory$ = function _getNativeDialogHistory$() {
        var callsite = (0, _getCallsite2.default)('getNativeDialogHistory');

        return this.testRun.executeCommand(new _actions.GetNativeDialogHistoryCommand(), callsite);
    };

    TestController.prototype._expect$ = function _expect$(actual) {
        return new _assertion2.default(actual, this);
    };

    return TestController;
}();

exports.default = TestController;


TestController.API_LIST = (0, _delegatedApi.getDelegatedAPIList)(TestController.prototype);

(0, _delegatedApi.delegateAPI)(TestController.prototype, TestController.prototype, TestController.API_LIST, null, true);
module.exports = exports['default'];